# 문제 링크
https://codeforces.com/contest/1509/problem/C

# 문제 설명
모든 i에 대해서 sum( max(a[1]~a[i])-min(a[1]~a[i]) )를 최소화하는 문제이다.

# 문제 풀이
a가 정렬되어 있다고 가정할 때, d[l][r]=a[r]-a[l]+min(d[l+1][r],d[l][r-1])인데,
그 이유는 a[l]~a[r]에서 a[l]과 a[r]이 각각 맨 마지막( 앞이든 뒤든 순서는 상관 없다)에 있지 않다면, 두 수를 모두 포함하는 prefix부터는 그 값과 상관없이 현재 배열에서 나올 수 있는 가장 큰 값인 a[r]-a[l]이 결과에 더해지기 때문이다. 
 따라서 a[l]과 a[r]을 양 끝에 배치해야 한다. 그렇게 한다면 a[l]을 가장 뒤에 배치하는 방법과 a[r]을 가장 뒤에 배치하는 방법이 있는데, a[l]을 맨 앞에 놓는 방법이 d[l+1][r] (a[l]이 제외되므로) , a[r]을 맨 앞에 놓는 방법이 d[ l][r-1]이다. 어차피 더해지는 수는 a[r]-a[l]로 동일하므로, 정리해 보면 d[l][r]=a[r]-a[l]+min(d[l+1][r],d[l][r-1])이 된다.

---

#문제 링크
https://codeforces.com/contest/1514/problem/C

#문제 설명
1 ~ n-1 사이의 수 중에서 몇 개의 수를 선택해서 전부 곱한 수를 n으로 나눈 나머지가 1이 되게 하는데, 최대한 많은 수를 선택하는 문제이다.

#문제 풀이
 의외로 매우 간단한데, gcd(n,i)=1 (n과 서로소)인 수들을 전부 선택한다. 그렇게 한다면 그 수들을 전부 곱한 수를 n으로 나눈 나머지는 p가 될 것인데, 그 p는 선택된 수 안에 있을 수 밖에 없으므로 p가 1인 경우를 제외하곤 p만 제외하고 전부 출력하면 된다.
 그렇게 하면 되는 이유는 n과 서로소가 아닌 수를 선택하면 product를 n으로 나눈 나머지가 1이 될 수가 없다. 그 이유는 그렇게 한다면 gcd(prod,n) != 1 이 되고, gcd를 구하는 과정을 생각해 본다면 gcd(prod,n)=gcd(prod%n,n)인데 이 값 역시 1이 아니다. 하지만 prod%n은 1이어야만 하는데(문제 정의), 모순되므로 n과 서로소가 아닌 수는 선택을 해서는 안된다. 
 따라서 n과 서로소가 아닌 수들을 전부 선택한 다음, 이 수들을 전부 곱한 다음 n으로나눈 나머지를 p라고 할 때, p가 선택된 수 안에 있는 이유는 간단하다. 앞서 말한 것을 식으로 나타내면 prod%n=p라는 것인데, 선택된 수는 서로소밖에 없으므로 gcd(prod,n)=gcd(prod%n, n)=1이 된다. 이때 gcd(prod%n(=p),n)=1이므로 선택된 수 안에 포함되어 있을 것이다. 이때 p가 1이면 삭제할 필요가 없고 1이 아니라면 선택된 수에서 p만 삭제하면 자동으로 prod%n=1이 되기 때문에 최대이다.  
